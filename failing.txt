PHPUnit 9.5.19 #StandWithUkraine

F                                                                   1 / 1 (100%)
anchor.json | Location-independent identifier: mismatch. Should have failed.
anchor.json | Location-independent identifier with absolute URI: mismatch. Should have failed.
anchor.json | Location-independent identifier with base URI change in subschema: mismatch. Should have failed.
anchor.json | $anchor inside an enum is not a real identifier: in implementations that strip $anchor, this may match either $def. Should have failed.
anchor.json | $anchor inside an enum is not a real identifier: no match on enum or $ref to $anchor. Should have failed.
anchor.json | same $anchor with different base uri: $ref should not resolve to /$defs/A/allOf/0. Should have failed.
Passed 6/12 tests

content.json | validation of binary-encoded media type documents: an invalid base64 string that is valid JSON; validates true.
    Failed with: Expected content mime type to be application/json got application/x-empty at #
content.json | validation of binary-encoded media type documents with schema: an invalid base64 string that is valid JSON; validates true.
    Failed with: Expected content mime type to be application/json got application/x-empty at #
Passed 16/18 tests

uniqueItems.json | uniqueItems with an array of items and additionalItems=false: [false, true] from items array is valid.
    Failed with: items as boolean is not yet implemented at #
uniqueItems.json | uniqueItems with an array of items and additionalItems=false: [true, false] from items array is valid.
    Failed with: items as boolean is not yet implemented at #
uniqueItems.json | uniqueItems=false with an array of items and additionalItems=false: [false, true] from items array is valid.
    Failed with: items as boolean is not yet implemented at #
uniqueItems.json | uniqueItems=false with an array of items and additionalItems=false: [true, false] from items array is valid.
    Failed with: items as boolean is not yet implemented at #
uniqueItems.json | uniqueItems=false with an array of items and additionalItems=false: [false, false] from items array is valid.
    Failed with: items as boolean is not yet implemented at #
uniqueItems.json | uniqueItems=false with an array of items and additionalItems=false: [true, true] from items array is valid.
    Failed with: items as boolean is not yet implemented at #
Passed 62/68 tests

Passed 4/4 tests

additionalProperties.json | additionalProperties being false does not allow other properties: an additional property is invalid. Should have failed.
additionalProperties.json | non-ASCII pattern with additionalProperties: not matching the pattern is invalid. Should have failed.
additionalProperties.json | additionalProperties allows a schema which should validate: an additional invalid property is invalid. Should have failed.
additionalProperties.json | additionalProperties can exist by itself: an additional invalid property is invalid. Should have failed.
additionalProperties.json | additionalProperties should not look in applicators: properties defined in allOf are not examined. Should have failed.
Passed 10/15 tests

Passed 4/4 tests

const.json | const validation: another value is invalid. Should have failed.
const.json | const validation: another type is invalid. Should have failed.
const.json | const with object: another object is invalid. Should have failed.
const.json | const with object: another type is invalid. Should have failed.
const.json | const with array: another array item is invalid. Should have failed.
const.json | const with array: array with additional items is invalid. Should have failed.
const.json | const with null: not null is invalid. Should have failed.
const.json | const with false does not match 0: integer zero is invalid. Should have failed.
const.json | const with false does not match 0: float zero is invalid. Should have failed.
const.json | const with true does not match 1: integer one is invalid. Should have failed.
const.json | const with true does not match 1: float one is invalid. Should have failed.
const.json | const with [false] does not match [0]: [0] is invalid. Should have failed.
const.json | const with [false] does not match [0]: [0.0] is invalid. Should have failed.
const.json | const with [true] does not match [1]: [1] is invalid. Should have failed.
const.json | const with [true] does not match [1]: [1.0] is invalid. Should have failed.
const.json | const with {"a": false} does not match {"a": 0}: {"a": 0} is invalid. Should have failed.
const.json | const with {"a": false} does not match {"a": 0}: {"a": 0.0} is invalid. Should have failed.
const.json | const with {"a": true} does not match {"a": 1}: {"a": 1} is invalid. Should have failed.
const.json | const with {"a": true} does not match {"a": 1}: {"a": 1.0} is invalid. Should have failed.
const.json | const with 0 does not match other zero-like types: false is invalid. Should have failed.
const.json | const with 0 does not match other zero-like types: empty object is invalid. Should have failed.
const.json | const with 0 does not match other zero-like types: empty array is invalid. Should have failed.
const.json | const with 0 does not match other zero-like types: empty string is invalid. Should have failed.
const.json | const with 1 does not match true: true is invalid. Should have failed.
const.json | const with -2.0 matches integer and float types: integer 2 is invalid. Should have failed.
const.json | const with -2.0 matches integer and float types: float 2.0 is invalid. Should have failed.
const.json | const with -2.0 matches integer and float types: float -2.00001 is invalid. Should have failed.
const.json | float and integers are equal up to 64-bit representation limits: integer minus one is invalid. Should have failed.
const.json | float and integers are equal up to 64-bit representation limits: float minus one is invalid. Should have failed.
const.json | nul characters in strings: do not match string lacking nul. Should have failed.
Passed 20/50 tests

defs.json | validate definition against metaschema: invalid definition schema. Should have failed.
Passed 1/2 tests

anyOf.json | anyOf with base schema: both anyOf invalid. Should have failed.
anyOf.json | anyOf with boolean schemas, all true: could not instanciate schematics from its content
anyOf.json | anyOf with boolean schemas, some true: could not instanciate schematics from its content
anyOf.json | anyOf with boolean schemas, all false: could not instanciate schematics from its content
anyOf.json | anyOf with boolean schemas, all false: any value is invalid. Should have failed.
anyOf.json | anyOf complex types: neither anyOf valid (complex). Should have failed.
anyOf.json | nested anyOf, to check validation semantics: anything non-null is invalid. Should have failed.
Passed 10/18 tests

propertyNames.json | propertyNames validation: could not instanciate schematics from its content
propertyNames.json | propertyNames validation: some property names invalid. Should have failed.
propertyNames.json | propertyNames with boolean schema false: object with any properties is invalid. Should have failed.
Passed 7/10 tests

unknownKeyword.json | $id inside an unknown keyword is not a real identifier: type matches non-schema in first anyOf. Should have failed.
unknownKeyword.json | $id inside an unknown keyword is not a real identifier: type matches non-schema in third anyOf. Should have failed.
Passed 1/3 tests

unevaluatedItems.json | unevaluatedItems true: with no unevaluated items.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems true: with unevaluated items.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems false: with no unevaluated items.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems as schema: with no unevaluated items.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems as schema: with valid unevaluated items.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems with uniform items: unevaluatedItems doesn't apply.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems with tuple: with no unevaluated items.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems with items: unevaluatedItems doesn't apply.
    Failed with: items as boolean is not yet implemented at #
unevaluatedItems.json | unevaluatedItems with nested tuple: could not instanciate schematics from its content
unevaluatedItems.json | unevaluatedItems with nested tuple: with no unevaluated items.
    Failed with: items as boolean is not yet implemented at #
unevaluatedItems.json | unevaluatedItems with nested items: with no additional items.
    Failed with: items as boolean is not yet implemented at #/allOf/0
unevaluatedItems.json | unevaluatedItems with nested items: with additional items.
    Failed with: items as boolean is not yet implemented at #/allOf/0
unevaluatedItems.json | unevaluatedItems with nested unevaluatedItems: with no additional items.
    Failed with: unevaluatedItems is not yet implemented at #/allOf/1
unevaluatedItems.json | unevaluatedItems with nested unevaluatedItems: with additional items.
    Failed with: unevaluatedItems is not yet implemented at #/allOf/1
unevaluatedItems.json | unevaluatedItems with anyOf: could not instanciate schematics from its content
unevaluatedItems.json | unevaluatedItems with anyOf: when one schema matches and has no unevaluated items.
    Failed with: unevaluatedItems is not yet implemented at #/allOf/1
unevaluatedItems.json | unevaluatedItems with anyOf: when two schemas match and has no unevaluated items.
    Failed with: unevaluatedItems is not yet implemented at #/allOf/1
unevaluatedItems.json | unevaluatedItems with oneOf: could not instanciate schematics from its content
unevaluatedItems.json | unevaluatedItems with oneOf: with no unevaluated items.
    Failed with: unevaluatedItems is not yet implemented at #/allOf/1
unevaluatedItems.json | unevaluatedItems with not: could not instanciate schematics from its content
unevaluatedItems.json | unevaluatedItems with if/then/else: when if matches and it has no unevaluated items.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems with if/then/else: when if doesn't match and it has no unevaluated items.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems with boolean schemas: could not instanciate schematics from its content
unevaluatedItems.json | unevaluatedItems with boolean schemas: with no unevaluated items.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems with $ref: could not instanciate schematics from its content
unevaluatedItems.json | unevaluatedItems with $ref: with no unevaluated items.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems can't see inside cousins: could not instanciate schematics from its content
unevaluatedItems.json | item is evaluated in an uncle schema to unevaluatedItems: could not instanciate schematics from its content
unevaluatedItems.json | item is evaluated in an uncle schema to unevaluatedItems: no extra items.
    Failed with: Expected type to be array, got array at #
unevaluatedItems.json | unevaluatedItems depends on adjacent contains: could not instanciate schematics from its content
unevaluatedItems.json | unevaluatedItems depends on adjacent contains: second item is evaluated by contains.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems depends on multiple nested contains: 5 not evaluated, passes unevaluatedItems.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems and contains interact to control item dependency relationship: empty array is valid.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems and contains interact to control item dependency relationship: only a's are valid.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems and contains interact to control item dependency relationship: a's and b's are valid.
    Failed with: unevaluatedItems is not yet implemented at #
unevaluatedItems.json | unevaluatedItems and contains interact to control item dependency relationship: a's, b's and c's are valid.
    Failed with: unevaluatedItems is not yet implemented at #
Passed 12/48 tests

boolean_schema.json | boolean schema 'true': could not instanciate schematics from its content
boolean_schema.json | boolean schema 'true': empty object is valid.
    Failed with: unevaluatedItems is not yet implemented at #
boolean_schema.json | boolean schema 'true': array is valid.
    Failed with: unevaluatedItems is not yet implemented at #
boolean_schema.json | boolean schema 'true': empty array is valid.
    Failed with: unevaluatedItems is not yet implemented at #
boolean_schema.json | boolean schema 'false': could not instanciate schematics from its content
boolean_schema.json | boolean schema 'false': number is invalid. Should have failed.
boolean_schema.json | boolean schema 'false': string is invalid. Should have failed.
boolean_schema.json | boolean schema 'false': boolean true is invalid. Should have failed.
boolean_schema.json | boolean schema 'false': boolean false is invalid. Should have failed.
boolean_schema.json | boolean schema 'false': null is invalid. Should have failed.
boolean_schema.json | boolean schema 'false': object is invalid. Should have failed.
Passed 7/18 tests

not.json | not: disallowed. Should have failed.
not.json | not multiple types: mismatch. Should have failed.
not.json | not multiple types: other mismatch. Should have failed.
not.json | not more complex schema: mismatch. Should have failed.
not.json | forbidden property: property present. Should have failed.
not.json | not with boolean schema true: could not instanciate schematics from its content
not.json | not with boolean schema true: any value is invalid. Should have failed.
not.json | not with boolean schema false: could not instanciate schematics from its content
Passed 4/12 tests

items.json | items with boolean schema (true): any array is valid.
    Failed with: items as boolean is not yet implemented at #
items.json | items with boolean schema (true): empty array is valid.
    Failed with: items as boolean is not yet implemented at #
items.json | items with boolean schema (false): empty array is valid.
    Failed with: items as boolean is not yet implemented at #
items.json | items and subitems: valid items.
    Failed with: items as boolean is not yet implemented at #
items.json | items and subitems: fewer items is valid.
    Failed with: items as boolean is not yet implemented at #
items.json | nested items: valid nested array.
    Failed with: Expected a number got integer at #/items/0/items/0/items/0/items/0
items.json | prefixItems with no additional items allowed: empty array.
    Failed with: items as boolean is not yet implemented at #
items.json | prefixItems with no additional items allowed: fewer number of items present (1).
    Failed with: items as boolean is not yet implemented at #
items.json | prefixItems with no additional items allowed: fewer number of items present (2).
    Failed with: items as boolean is not yet implemented at #
items.json | prefixItems with no additional items allowed: equal number of items present.
    Failed with: items as boolean is not yet implemented at #
items.json | prefixItems validation adjusts the starting index for items: valid items.
    Failed with: Expected type to be ' . integer . ', got string at #/items/0
Passed 15/26 tests

enum.json | enums in properties: both properties are valid.
    Failed with: Expected type to be ' . object . ', got array at #
enum.json | enums in properties: missing optional property is valid.
    Failed with: Expected type to be ' . object . ', got array at #
enum.json | enum with 0 does not match false: float zero is valid.
    Failed with: Expected value within [0] got `0` at #
enum.json | enum with 1 does not match true: float one is valid.
    Failed with: Expected value within [1] got `1` at #
Passed 29/33 tests

minProperties.json | minProperties validation: too short is invalid. Should have failed.
Passed 5/6 tests

minContains.json | minContains=1 with contains: no elements match. Should have failed.
minContains.json | minContains=2 with contains: some elements match, invalid minContains. Should have failed.
minContains.json | minContains = 0: empty data.
    Failed with: Expected at least one item to validate against:\n{
    "const": 1
} at #
minContains.json | minContains = 0 with maxContains: empty data.
    Failed with: Expected at least one item to validate against:\n{
    "const": 1
} at #
Passed 22/26 tests

properties.json | object properties validation: one property invalid is invalid. Should have failed.
properties.json | object properties validation: both properties invalid is invalid. Should have failed.
properties.json | properties, patternProperties, additionalProperties interaction: property invalidates property. Should have failed.
properties.json | properties, patternProperties, additionalProperties interaction: patternProperty invalidates property. Should have failed.
properties.json | properties, patternProperties, additionalProperties interaction: patternProperty invalidates nonproperty. Should have failed.
properties.json | properties, patternProperties, additionalProperties interaction: additionalProperty invalidates others. Should have failed.
properties.json | properties with boolean schema: could not instanciate schematics from its content
properties.json | properties with boolean schema: only 'false' property present is invalid. Should have failed.
properties.json | properties with boolean schema: both properties present is invalid. Should have failed.
properties.json | properties with escaped characters: object with strings is invalid. Should have failed.
Passed 10/20 tests

maxContains.json | maxContains with contains: some elements match, valid maxContains.
    Failed with: Expected at most ' . 1 . ' to validate against `contains` elements got 2 at #
Passed 9/10 tests

maxLength.json | maxLength validation: too long is invalid. Should have failed.
Passed 3/5 tests

dependentSchemas.json | single dependency: wrong type. Should have failed.
dependentSchemas.json | single dependency: wrong type other. Should have failed.
dependentSchemas.json | single dependency: wrong type both. Should have failed.
dependentSchemas.json | boolean subschemas: object with property having schema false is invalid. Should have failed.
dependentSchemas.json | boolean subschemas: object with both properties is invalid. Should have failed.
dependentSchemas.json | dependencies with escaped characters: quoted quote. Should have failed.
dependentSchemas.json | dependencies with escaped characters: quoted tab invalid under dependent schema. Should have failed.
dependentSchemas.json | dependencies with escaped characters: quoted quote invalid under dependent schema. Should have failed.
Passed 8/16 tests

infinite-loop-detection.json | evaluating the same schema location against the same data location twice is not a sign of an infinite loop: failing case. Should have failed.
Passed 1/2 tests

Passed 4/4 tests

prefixItems.json | a schema given for prefixItems: incomplete array of items.
    Failed with: Expected type to be ' . string . ', got NULL at #/prefixItems/1
prefixItems.json | a schema given for prefixItems: empty array.
    Failed with: Expected type to be ' . integer . ', got NULL at #/prefixItems/0
prefixItems.json | prefixItems with boolean schemas: could not instanciate schematics from its content
prefixItems.json | prefixItems with boolean schemas: array with one item is valid.
    Failed with: Expected type to be ' . string . ', got NULL at #/prefixItems/1
prefixItems.json | prefixItems with boolean schemas: array with two items is invalid. Should have failed.
prefixItems.json | prefixItems with boolean schemas: empty array is valid.
    Failed with: Expected type to be ' . integer . ', got NULL at #/prefixItems/0
Passed 4/10 tests

Passed 11/11 tests

oneOf.json | oneOf: both oneOf valid. Should have failed.
oneOf.json | oneOf with base schema: both oneOf valid. Should have failed.
oneOf.json | oneOf with boolean schemas, all true: could not instanciate schematics from its content
oneOf.json | oneOf with boolean schemas, all true: any value is invalid. Should have failed.
oneOf.json | oneOf with boolean schemas, one true: could not instanciate schematics from its content
oneOf.json | oneOf with boolean schemas, more than one true: could not instanciate schematics from its content
oneOf.json | oneOf with boolean schemas, more than one true: any value is invalid. Should have failed.
oneOf.json | oneOf with boolean schemas, all false: could not instanciate schematics from its content
oneOf.json | oneOf with boolean schemas, all false: any value is invalid. Should have failed.
oneOf.json | oneOf complex types: both oneOf valid (complex). Should have failed.
oneOf.json | oneOf complex types: neither oneOf valid (complex). Should have failed.
oneOf.json | oneOf with empty schema: both valid - invalid. Should have failed.
oneOf.json | oneOf with required: first valid - valid.
    Failed with: Expected type to be ' . object . ', got array at #
oneOf.json | oneOf with required: second valid - valid.
    Failed with: Expected type to be ' . object . ', got array at #
oneOf.json | oneOf with missing optional property: could not instanciate schematics from its content
oneOf.json | oneOf with missing optional property: first oneOf valid.
    Failed with: Expected type to be ' . object . ', got array at #
oneOf.json | oneOf with missing optional property: second oneOf valid.
    Failed with: Expected type to be ' . object . ', got array at #
oneOf.json | nested oneOf, to check validation semantics: anything non-null is invalid. Should have failed.
Passed 8/27 tests

if-then-else.json | if and then without else: invalid through then. Should have failed.
if-then-else.json | if and else without then: invalid through else. Should have failed.
if-then-else.json | validate against correct branch, then vs else: invalid through then. Should have failed.
if-then-else.json | validate against correct branch, then vs else: invalid through else. Should have failed.
if-then-else.json | if with boolean schema true: boolean schema true in if always chooses the then path (invalid). Should have failed.
if-then-else.json | if with boolean schema false: boolean schema false in if always chooses the else path (invalid). Should have failed.
if-then-else.json | if appears at the end when serialized (keyword processing sequence): no redirects to then and fails. Should have failed.
if-then-else.json | if appears at the end when serialized (keyword processing sequence): invalid redirects to else and fails. Should have failed.
Passed 18/26 tests

Passed 9/9 tests

unevaluatedProperties.json | unevaluatedProperties true: with no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties true: with unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties schema: could not instanciate schematics from its content
unevaluatedProperties.json | unevaluatedProperties schema: with no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties schema: with valid unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties false: with no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with adjacent properties: with no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with adjacent patternProperties: with no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with adjacent additionalProperties: with no additional properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with adjacent additionalProperties: with additional properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with nested properties: with no additional properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with nested patternProperties: with no additional properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with nested additionalProperties: with no additional properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with nested additionalProperties: with additional properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with nested unevaluatedProperties: could not instanciate schematics from its content
unevaluatedProperties.json | unevaluatedProperties with nested unevaluatedProperties: with no nested unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with nested unevaluatedProperties: with nested unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with anyOf: when one matches and has no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with anyOf: when two match and has no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with oneOf: with no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with if/then/else: when if is true and has no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with if/then/else: when if is false and has no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with if/then/else, then not defined: when if is false and has no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with if/then/else, else not defined: when if is true and has no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with dependentSchemas: with no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with boolean schemas: could not instanciate schematics from its content
unevaluatedProperties.json | unevaluatedProperties with boolean schemas: with no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties with $ref: with no unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties can't see inside cousins: could not instanciate schematics from its content
unevaluatedProperties.json | nested unevaluatedProperties, outer false, inner true, properties outside: with no nested unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | nested unevaluatedProperties, outer false, inner true, properties outside: with nested unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | nested unevaluatedProperties, outer false, inner true, properties inside: with no nested unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | nested unevaluatedProperties, outer false, inner true, properties inside: with nested unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | nested unevaluatedProperties, outer true, inner false, properties inside: with no nested unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | cousin unevaluatedProperties, true and false, false with properties: with no nested unevaluated properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | property is evaluated in an uncle schema to unevaluatedProperties: no extra properties.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | in-place applicator siblings, allOf has unevaluated: could not instanciate schematics from its content
unevaluatedProperties.json | in-place applicator siblings, allOf has unevaluated: in place applicator siblings, bar is missing.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | in-place applicator siblings, anyOf has unevaluated: could not instanciate schematics from its content
unevaluatedProperties.json | in-place applicator siblings, anyOf has unevaluated: in place applicator siblings, foo is missing.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties + single cyclic ref: Empty is valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties + single cyclic ref: Single is valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties + single cyclic ref: Nested is valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties + single cyclic ref: Deep nested is valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties + ref inside allOf / oneOf: could not instanciate schematics from its content
unevaluatedProperties.json | unevaluatedProperties + ref inside allOf / oneOf: a and x are valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties + ref inside allOf / oneOf: a and y are valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties + ref inside allOf / oneOf: a and b and x are valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | unevaluatedProperties + ref inside allOf / oneOf: a and b and y are valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | dynamic evalation inside nested refs: could not instanciate schematics from its content
unevaluatedProperties.json | dynamic evalation inside nested refs: a is valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | dynamic evalation inside nested refs: b is valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | dynamic evalation inside nested refs: c is valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | dynamic evalation inside nested refs: d is valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | dynamic evalation inside nested refs: xx is valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | dynamic evalation inside nested refs: xx + foox is valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | dynamic evalation inside nested refs: all is valid.
    Failed with: Expected type to be ' . object . ', got array at #
unevaluatedProperties.json | dynamic evalation inside nested refs: all + foo is valid.
    Failed with: Expected type to be ' . object . ', got array at #
Passed 45/103 tests

maxProperties.json | maxProperties validation: too long is invalid. Should have failed.
maxProperties.json | maxProperties = 0 means the object is empty: one property is invalid. Should have failed.
Passed 6/8 tests

dependentRequired.json | single dependency: missing dependency. Should have failed.
dependentRequired.json | multiple dependents required: missing dependency. Should have failed.
dependentRequired.json | multiple dependents required: missing other dependency. Should have failed.
dependentRequired.json | multiple dependents required: missing both dependencies. Should have failed.
dependentRequired.json | dependencies with escaped characters: CRLF missing dependent. Should have failed.
dependentRequired.json | dependencies with escaped characters: quoted quotes missing dependent. Should have failed.
Passed 14/20 tests

required.json | required validation: non-present required property is invalid. Should have failed.
required.json | required with escaped characters: object with some properties missing is invalid. Should have failed.
Passed 7/9 tests

id.json | Invalid use of fragments in location-independent $id: Identifier name. Should have failed.
id.json | Invalid use of fragments in location-independent $id: Identifier name and no ref. Should have failed.
id.json | Invalid use of fragments in location-independent $id: Identifier path. Should have failed.
id.json | Invalid use of fragments in location-independent $id: Identifier name with absolute URI. Should have failed.
id.json | Invalid use of fragments in location-independent $id: Identifier path with absolute URI. Should have failed.
id.json | Invalid use of fragments in location-independent $id: Identifier name with base URI change in subschema. Should have failed.
id.json | Invalid use of fragments in location-independent $id: Identifier path with base URI change in subschema. Should have failed.
id.json | $id inside an enum is not a real identifier: no match on enum or $ref to $id. Should have failed.
Passed 8/16 tests

type.json | integer type matches integers: a float with zero fractional part is an integer.
    Failed with: Expected an integer got double at #
type.json | number type matches numbers: an integer is a number.
    Failed with: Expected a number got integer at #
type.json | object type matches objects: an object is an object.
    Failed with: Expected type to be ' . object . ', got array at #
type.json | array type matches arrays: an object is not an array. Should have failed.
type.json | boolean type matches booleans: an integer is not a boolean. Should have failed.
type.json | boolean type matches booleans: zero is not a boolean. Should have failed.
type.json | boolean type matches booleans: a float is not a boolean. Should have failed.
type.json | boolean type matches booleans: a string is not a boolean. Should have failed.
type.json | boolean type matches booleans: an empty string is not a boolean. Should have failed.
type.json | boolean type matches booleans: an object is not a boolean. Should have failed.
type.json | boolean type matches booleans: an array is not a boolean. Should have failed.
type.json | boolean type matches booleans: null is not a boolean. Should have failed.
type.json | null type matches only the null object: an integer is not null. Should have failed.
type.json | null type matches only the null object: a float is not null. Should have failed.
type.json | null type matches only the null object: zero is not null. Should have failed.
type.json | null type matches only the null object: a string is not null. Should have failed.
type.json | null type matches only the null object: an empty string is not null. Should have failed.
type.json | null type matches only the null object: an object is not null. Should have failed.
type.json | null type matches only the null object: an array is not null. Should have failed.
type.json | null type matches only the null object: true is not null. Should have failed.
type.json | null type matches only the null object: false is not null. Should have failed.
type.json | multiple types can be specified in an array: a float is invalid. Should have failed.
type.json | multiple types can be specified in an array: an object is invalid. Should have failed.
type.json | multiple types can be specified in an array: an array is invalid. Should have failed.
type.json | multiple types can be specified in an array: a boolean is invalid. Should have failed.
type.json | multiple types can be specified in an array: null is invalid. Should have failed.
type.json | type as array with one item: number is invalid. Should have failed.
type.json | type: array or object: number is invalid. Should have failed.
type.json | type: array or object: string is invalid. Should have failed.
type.json | type: array or object: null is invalid. Should have failed.
type.json | type: array, object or null: number is invalid. Should have failed.
type.json | type: array, object or null: string is invalid. Should have failed.
Passed 48/80 tests

default.json | the default keyword does not do anything if the property is missing: an explicit property value is checked against maximum (passing).
    Failed with: Expected type to be ' . object . ', got array at #
default.json | the default keyword does not do anything if the property is missing: missing properties are not filled in with the default.
    Failed with: Expected type to be ' . object . ', got array at #
Passed 5/7 tests

multipleOf.json | by number: 35 is not multiple of 1.5. Should have failed.
Passed 6/9 tests

patternProperties.json | patternProperties validates properties matching a regex: a single invalid match is invalid. Should have failed.
patternProperties.json | patternProperties validates properties matching a regex: multiple invalid matches is invalid. Should have failed.
patternProperties.json | multiple simultaneous patternProperties are validated: an invalid due to one is invalid. Should have failed.
patternProperties.json | multiple simultaneous patternProperties are validated: an invalid due to the other is invalid. Should have failed.
patternProperties.json | multiple simultaneous patternProperties are validated: an invalid due to both is invalid. Should have failed.
patternProperties.json | regexes are not anchored by default and are case sensitive: recognized members are accounted for. Should have failed.
patternProperties.json | regexes are not anchored by default and are case sensitive: regexes are case sensitive, 2. Should have failed.
patternProperties.json | patternProperties with boolean schemas: could not instanciate schematics from its content
patternProperties.json | patternProperties with boolean schemas: object with property matching schema false is invalid. Should have failed.
patternProperties.json | patternProperties with boolean schemas: object with both properties is invalid. Should have failed.
patternProperties.json | patternProperties with boolean schemas: object with a property matching both true and false is invalid. Should have failed.
Passed 11/22 tests

refRemote.json | remote ref: remote ref invalid. Should have failed.
refRemote.json | fragment within remote ref: remote fragment invalid. Should have failed.
refRemote.json | ref within remote ref: ref within ref invalid. Should have failed.
refRemote.json | base URI change: base URI change ref invalid. Should have failed.
refRemote.json | base URI change - change folder: number is valid.
    Failed with: Expected type to be ' . object . ', got array at #
refRemote.json | base URI change - change folder in subschema: number is valid.
    Failed with: Expected type to be ' . object . ', got array at #
refRemote.json | root ref in remote ref: string is valid.
    Failed with: Expected type to be ' . object . ', got array at #
refRemote.json | root ref in remote ref: null is valid.
    Failed with: Expected type to be ' . object . ', got array at #
refRemote.json | remote ref with ref to defs: invalid. Should have failed.
Passed 8/17 tests

allOf.json | allOf: mismatch second. Should have failed.
allOf.json | allOf: mismatch first. Should have failed.
allOf.json | allOf: wrong type. Should have failed.
allOf.json | allOf with base schema: mismatch base schema. Should have failed.
allOf.json | allOf with base schema: mismatch first allOf. Should have failed.
allOf.json | allOf with base schema: mismatch second allOf. Should have failed.
allOf.json | allOf with base schema: mismatch both. Should have failed.
allOf.json | allOf with boolean schemas, all true: could not instanciate schematics from its content
allOf.json | allOf with boolean schemas, some false: could not instanciate schematics from its content
allOf.json | allOf with boolean schemas, some false: any value is invalid. Should have failed.
allOf.json | allOf with boolean schemas, all false: could not instanciate schematics from its content
allOf.json | allOf with boolean schemas, all false: any value is invalid. Should have failed.
allOf.json | allOf with the first empty schema: number is valid.
    Failed with: Expected a number got integer at #/allOf/1
allOf.json | allOf with the last empty schema: number is valid.
    Failed with: Expected a number got integer at #/allOf/0
allOf.json | nested allOf, to check validation semantics: anything non-null is invalid. Should have failed.
Passed 15/30 tests

Passed 114/114 tests

ref.json | root pointer ref: mismatch. Should have failed.
ref.json | root pointer ref: recursive mismatch. Should have failed.
ref.json | relative pointer ref to object: mismatch. Should have failed.
ref.json | relative pointer ref to array: mismatch array. Should have failed.
ref.json | escaped pointer ref: slash invalid. Should have failed.
ref.json | escaped pointer ref: tilde invalid. Should have failed.
ref.json | escaped pointer ref: percent invalid. Should have failed.
ref.json | nested refs: nested ref invalid. Should have failed.
ref.json | ref applies alongside sibling keywords: ref valid, maxItems invalid. Should have failed.
ref.json | ref applies alongside sibling keywords: ref invalid. Should have failed.
ref.json | remote ref, containing refs itself: remote ref invalid. Should have failed.
ref.json | property named $ref that is not a reference: property named $ref invalid. Should have failed.
ref.json | property named $ref, containing an actual $ref: property named $ref invalid. Should have failed.
ref.json | $ref to boolean schema true: could not instanciate schematics from its content
ref.json | $ref to boolean schema false: could not instanciate schematics from its content
ref.json | $ref to boolean schema false: any value is invalid. Should have failed.
ref.json | Recursive references between schemas: valid tree.
    Failed with: Expected type to be ' . object . ', got array at #
ref.json | refs with quote: object with strings is invalid. Should have failed.
ref.json | ref creates new scope when adjacent to keywords: referenced subschema doesn't see annotations from properties. Should have failed.
ref.json | refs with relative uris and defs: invalid on inner field. Should have failed.
ref.json | refs with relative uris and defs: invalid on outer field. Should have failed.
ref.json | relative refs with absolute uris and defs: invalid on inner field. Should have failed.
ref.json | relative refs with absolute uris and defs: invalid on outer field. Should have failed.
ref.json | $id must be resolved against nearest parent, not just immediate parent: non-number should fail. Should have failed.
Passed 19/43 tests

Passed 8/8 tests

minLength.json | minLength validation: too short is invalid. Should have failed.
minLength.json | minLength validation: one supplementary Unicode code point is not long enough. Should have failed.
Passed 2/5 tests

Passed 4/4 tests

contains.json | contains keyword validation: not array is valid.
    Failed with: Expected at least one item to validate against:\n{
    "minimum": 5
} at #
contains.json | contains keyword with const keyword: array without item 5 is invalid. Should have failed.
contains.json | contains keyword with boolean schema true: could not instanciate schematics from its content
contains.json | contains keyword with boolean schema false: could not instanciate schematics from its content
contains.json | contains keyword with boolean schema false: any non-empty array is invalid. Should have failed.
Passed 15/20 tests

dynamicRef.json | A $dynamicRef to a $dynamicAnchor in the same schema resource should behave like a normal $ref to an $anchor: An array containing non-strings is invalid. Should have failed.
dynamicRef.json | A $dynamicRef to an $anchor in the same schema resource should behave like a normal $ref to an $anchor: An array containing non-strings is invalid. Should have failed.
dynamicRef.json | A $ref to a $dynamicAnchor in the same schema resource should behave like a normal $ref to an $anchor: An array containing non-strings is invalid. Should have failed.
dynamicRef.json | A $dynamicRef should resolve to the first $dynamicAnchor still in scope that is encountered when the schema is evaluated: An array containing non-strings is invalid. Should have failed.
dynamicRef.json | A $dynamicRef with intermediate scopes that don't include a matching $dynamicAnchor should not affect dynamic scope resolution: An array containing non-strings is invalid. Should have failed.
dynamicRef.json | A $dynamicRef that initially resolves to a schema with a matching $dynamicAnchor should resolve to the first $dynamicAnchor in the dynamic scope: The recursive part is valid against the root.
    Failed with: Expected type to be ' . object . ', got array at #
dynamicRef.json | A $dynamicRef that initially resolves to a schema without a matching $dynamicAnchor should behave like a normal $ref to $anchor: The recursive part doesn't need to validate against the root.
    Failed with: Expected type to be ' . object . ', got array at #
dynamicRef.json | multiple dynamic paths to the $dynamicRef keyword: recurse to integerNode - floats are not allowed. Should have failed.
dynamicRef.json | after leaving a dynamic scope, it should not be used by a $dynamicRef: string matches /$defs/thingy, but the $dynamicRef does not stop here. Should have failed.
dynamicRef.json | after leaving a dynamic scope, it should not be used by a $dynamicRef: first_scope is not in dynamic scope for the $dynamicRef. Should have failed.
dynamicRef.json | strict-tree schema, guards against misspelled properties: instance with misspelled field. Should have failed.
dynamicRef.json | tests for implementation dynamic anchor and reference link: could not instanciate schematics from its content
dynamicRef.json | tests for implementation dynamic anchor and reference link: incorrect parent schema. Should have failed.
dynamicRef.json | tests for implementation dynamic anchor and reference link: incorrect extended schema. Should have failed.
dynamicRef.json | Tests for implementation dynamic anchor and reference link. Reference should be independent of any possible ordering.: could not instanciate schematics from its content
dynamicRef.json | Tests for implementation dynamic anchor and reference link. Reference should be independent of any possible ordering.: incorrect parent schema. Should have failed.
dynamicRef.json | Tests for implementation dynamic anchor and reference link. Reference should be independent of any possible ordering.: incorrect extended schema. Should have failed.
dynamicRef.json | Tests for implementation dynamic anchor and reference link. Reference should be independent of any possible ordering.: could not instanciate schematics from its content
dynamicRef.json | Tests for implementation dynamic anchor and reference link. Reference should be independent of any possible ordering.: incorrect parent schema. Should have failed.
dynamicRef.json | Tests for implementation dynamic anchor and reference link. Reference should be independent of any possible ordering.: incorrect extended schema. Should have failed.
Passed 12/32 tests


Passed in total 667/1060 tests


Time: 00:00.042, Memory: 6.00 MB

There was 1 failure:

1) OrgTest::testOrg
Failed asserting that an array is empty.

/Users/giann/git/brs/schematics/tests/OrgTest.php:102
phpvfscomposer:///Users/giann/git/brs/schematics/vendor/phpunit/phpunit/phpunit:97

FAILURES!
Tests: 1, Assertions: 1, Failures: 1.
